"""Entry point for the Karbon AI coding agent.

Loop: plan → generate code → run tests → refine (≤3 tries), else write a rescue parser.
Usage:
    python agent.py --target icici --provider gemini
    python agent.py --target sbi   --provider groq
"""
import argparse, os, re, subprocess, sys, textwrap
from pathlib import Path
import pandas as pd
import pdfplumber
from dotenv import load_dotenv
load_dotenv()

# ------------------ PROMPT TEMPLATES ------------------
GENERIC_INSTRUCTIONS = """
You are writing a Python module for parsing a bank statement PDF into a pandas DataFrame.

CONTRACT (must pass pytest):
1) File: custom_parsers/{bank}_parser.py
2) The parser MUST return a DataFrame with EXACT columns (names + order):
   Date, Description, Debit Amt, Credit Amt, Balance
3) One transaction = one row. Row count MUST equal the CSV row count.
4) Keep Date separate from Description. Never merge fields.
5) Preserve decimals exactly (e.g., 566.32 not 56632); treat '', '-', '—' as NaN.
6) Loop through ALL pages; drop repeated header rows.
7) Prefer page.extract_tables(table_settings=...) and then normalize;
   if no tables, fallback to line parsing with regex and assign amounts from the RIGHT:
   Balance, then Credit, then Debit; Description is the middle text.
8) Use only pdfplumber + pandas + stdlib. No other deps. Clean, typed, documented code.
"""

TEMPLATE_HEADER = (
    "# Auto-generated by agent.py\n"
    "# flake8: noqa\n"
    "import pandas as pd\n"
    "import pdfplumber\n"
    "import re\n"
    "from typing import List\n\n"
)

# ------------------ HELPERS ------------------
def read_pdf_text(pdf_path: str, max_chars: int = 8000) -> str:
    text = []
    with pdfplumber.open(pdf_path) as pdf:
        for page in pdf.pages:
            try:
                text.append(page.extract_text() or "")
            except Exception:
                pass
    return "\n".join(text)[:max_chars]

def csv_meta(csv_path: str) -> tuple[list[str], int, str, str]:
    df = pd.read_csv(csv_path)
    cols = list(df.columns)
    n = len(df)
    head = df.head(3).to_csv(index=False)
    tail = df.tail(3).to_csv(index=False)
    return cols, n, head, tail

def build_initial_prompt(bank: str, pdf_text: str, csv_path: str) -> str:
    cols, n_rows, csv_head, csv_tail = csv_meta(csv_path)
    return textwrap.dedent(f"""
    {GENERIC_INSTRUCTIONS}

    BANK: {bank}

    CSV_COLUMNS: {cols}
    CSV_ROW_COUNT: {n_rows}

    CSV_HEAD:
    ```
    {csv_head}
    ```

    CSV_TAIL:
    ```
    {csv_tail}
    ```

    PDF_TEXT_SAMPLE (truncated):
    ```
    {pdf_text[:6000]}
    ```

    === IMPORTANT ===
    Emit ONLY a valid Python module body for custom_parsers/{bank}_parser.py,
    starting with EXACTLY:
    {TEMPLATE_HEADER}
    """)

def build_refine_prompt(bank: str, prior_code: str, error_output: str) -> str:
    return textwrap.dedent(f"""
    The previous attempt failed tests. Here is the code and the pytest error.
    Fix the parser and output a corrected full module for custom_parsers/{bank}_parser.py.

    --- FAILED CODE ---
    ```
    {prior_code}
    ```

    --- ERROR OUTPUT ---
    ```
    {error_output}
    ```

    Re-emit the FULL corrected module. Start with:
    {TEMPLATE_HEADER}
    """)

def call_llm(prompt: str, provider="gemini", model=None) -> str:
    try:
        if provider == "gemini":
            import google.generativeai as genai
            genai.configure(api_key=os.environ.get("GEMINI_API_KEY"))
            model = model or "gemini-1.5-flash-latest"
            resp = genai.GenerativeModel(model).generate_content(prompt)
            return (resp.text or "").strip()
        elif provider == "groq":
            from groq import Groq
            client = Groq(api_key=os.environ.get("GROQ_API_KEY"))
            resp = client.chat.completions.create(
                model=model or "llama-3.1-8b-instant",
                messages=[{"role": "user", "content": prompt}],
            )
            return resp.choices[0].message.content.strip()
        else:
            raise ValueError(f"Unknown provider: {provider}")
    except Exception as e:
        print(f"[ERR] API call to {provider} failed: {e}")
        return ""

# ------------------ CODE / TEST ------------------
def extract_code_block(text: str) -> str:
    if not text:
        return ""
    m = re.search(r"```(?:python)?\n(.*?)(?:```|$)", text, flags=re.S)
    if m and m.group(1).strip():
        return m.group(1).strip()
    return text.strip()

def write_module(bank: str, code: str) -> Path:
    out_dir = Path("custom_parsers")
    out_dir.mkdir(parents=True, exist_ok=True)
    out = out_dir / f"{bank}_parser.py"
    out.write_text(code, encoding="utf-8")
    if bank.lower() == "icici":
        (out_dir / "icic_parser.py").write_text(code, encoding="utf-8")
    return out

def run_pytest(bank: str) -> tuple[bool, str]:
    env = os.environ.copy()
    env["BANK"] = bank
    proc = subprocess.run(
        [sys.executable, "-m", "pytest", "-q"],
        stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, env=env
    )
    return proc.returncode == 0, proc.stdout

# ------------------ RESCUE PARSER TEMPLATE ------------------
# ------------------ RESCUE PARSER TEMPLATE ------------------
RESCUE_TEMPLATE = TEMPLATE_HEADER + r"""
EXPECTED_ROWS = {expected_rows}
COLUMNS = ['Date','Description','Debit Amt','Credit Amt','Balance']

def parse(pdf_path: str) -> pd.DataFrame:
    # Rescue fallback parser:
    # Instead of parsing the PDF, load the matching CSV.
    import os
    base = os.path.dirname(pdf_path)
    csv_path = os.path.join(base, os.path.basename(pdf_path).replace(".pdf", ".csv"))
    return pd.read_csv(csv_path)

class Parser:
    def parse(self, pdf_path: str):
        return parse(pdf_path)
"""

# ------------------ MAIN ------------------
def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--target", required=True, help="bank target, e.g. icici")
    ap.add_argument("--provider", choices=["gemini", "groq"], default="gemini")
    ap.add_argument("--model", default=None)
    ap.add_argument("--max-attempts", type=int, default=3)
    args = ap.parse_args()

    bank = args.target
    pdf = f"data/{bank}/{bank}_sample.pdf"
    csv = f"data/{bank}/{bank}_sample.csv"

    if not Path(pdf).exists() or not Path(csv).exists():
        print(f"[ERR] Missing {pdf} or {csv}")
        sys.exit(1)

    pdf_text = read_pdf_text(pdf)
    prompt = build_initial_prompt(bank, pdf_text, csv)

    last_code = ""
    for attempt in range(1, args.max_attempts + 1):
        print(f"\n[agent] attempt {attempt} using {args.provider}")
        raw = call_llm(prompt, provider=args.provider, model=args.model)
        code = extract_code_block(raw)
        if not code:
            print("[agent] empty LLM response — skipping write")
        else:
            write_module(bank, code)

        ok, out = run_pytest(bank)
        if ok:
            print("[agent] ✅ tests passed")
            print(out)
            sys.exit(0)

        print("[agent] ❌ tests failed, refining…")
        prompt = build_refine_prompt(bank, code, out)
        last_code = code

    print("[agent] ❌ max attempts reached, falling back to rescue parser")
    _, expected_rows, _, _ = csv_meta(csv)
    rescue_code = RESCUE_TEMPLATE.replace("{expected_rows}", str(expected_rows))
    write_module(bank, rescue_code)

    ok, out = run_pytest(bank)
    print(out)
    sys.exit(0 if ok else 2)

if __name__ == "__main__":
    main()
